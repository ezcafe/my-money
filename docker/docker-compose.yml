# Docker Compose configuration for My Money Application
# Note: version field is obsolete in Docker Compose v2+

services:
  # PostgreSQL database service
  # Uncomment and configure for local development
  # For production, use managed database service (RDS, Cloud SQL, etc.)
  postgres:
    image: postgres:18-alpine
    container_name: my-money-postgres
    labels:
      - "com.docker.compose.project=my-money"
      - "com.docker.compose.service=postgres"
      - "security.scan=true"
      - "security.policy=restricted"
    env_file:
      - ../.env
    environment:
      # Require explicit POSTGRES_USER and POSTGRES_PASSWORD in production
      # For development, set these in .env file
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB:-mymoney}
    # PostgreSQL 18 Asynchronous I/O (AIO) configuration
    # AIO improves I/O performance for sequential scans, bitmap heap scans, and maintenance tasks
    # Use password authentication with scram-sha-256 (secure default)
    command: >
      postgres
      -c io_method=worker
      -c io_workers=3
      -c effective_io_concurrency=16
      -c maintenance_io_concurrency=16
      -c io_max_concurrency=-1
      -c io_combine_limit=128kB
      -c io_max_combine_limit=128kB
      -c password_encryption=scram-sha-256
    # Database port exposed for local development only
    # Remove in production or use conditional port mapping
    ports:
      - "5432:5432"
    # Mount named volume at parent path so the image's anonymous volume at
    # /var/lib/postgresql does not shadow our volume and cause data loss on down/up.
    volumes:
      - postgres_data:/var/lib/postgresql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - my-money-network
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    restart: unless-stopped
    security_opt:
      - no-new-privileges:true

  backend:
    build:
      context: ..
      dockerfile: docker/Dockerfile.backend
      args:
        BUILD_DATE: ${BUILD_DATE:-$(date -u +'%Y-%m-%dT%H:%M:%SZ')}
        VCS_REF: ${VCS_REF:-$(git rev-parse --short HEAD 2>/dev/null || echo 'unknown')}
        VERSION: ${VERSION:-1.0.0}
        NODE_VERSION: ${NODE_VERSION:-25.2.1}
    container_name: my-money-backend
    labels:
      - "com.docker.compose.project=my-money"
      - "com.docker.compose.service=backend"
      - "security.scan=true"
      - "security.policy=restricted"
      - "prometheus.scrape=true"
      - "prometheus.port=4000"
      - "prometheus.path=/metrics"
    env_file:
      - ../.env
    environment:
      # Database connection - construct DATABASE_URL with correct Docker hostname
      # IMPORTANT: Use 'postgres' (the service name) as host, NOT localhost
      # localhost inside Docker refers to the container itself, not the postgres service
      DATABASE_URL: "postgresql://${POSTGRES_USER:-postgres}:${POSTGRES_PASSWORD:-postgres}@postgres:5432/${POSTGRES_DB:-mymoney}?connection_limit=100&pool_timeout=20&connect_timeout=10"
      # Individual components for reference/fallback
      POSTGRES_USER: "${POSTGRES_USER:-postgres}"
      POSTGRES_PASSWORD: "${POSTGRES_PASSWORD:-postgres}"
      POSTGRES_DB: "${POSTGRES_DB:-mymoney}"
      POSTGRES_HOST: "postgres"
      PORT: ${PORT:-4000}
      NODE_ENV: production
      # Cookie configuration for Docker HTTP (not HTTPS)
      # Set USE_HTTPS=false to allow cookies over HTTP in Docker
      USE_HTTPS: ${USE_HTTPS:-false}
      # Node.js memory limit (768MB out of 1GB limit, leaving room for other processes)
      NODE_OPTIONS: "--max-old-space-size=768"
      # Database connection pool settings
      DATABASE_POOL_MIN: ${DATABASE_POOL_MIN:-2}
      DATABASE_POOL_MAX: ${DATABASE_POOL_MAX:-10}
      # URLs for OAuth callback and frontend redirect
      # These are required for proper OAuth flow in Docker environment
      BACKEND_URL: ${BACKEND_URL:-http://localhost:4000}
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3000}
      # CORS origins - frontend URL for cookie credentials
      CORS_ORIGIN: ${CORS_ORIGIN:-http://localhost:3000}
      # OIDC variables are loaded from env_file (.env) above
      # No need to set them explicitly here - env_file will load them into the container
    ports:
      - "${BACKEND_PORT:-4000}:4000"
    # Wait for postgres to be healthy before starting backend
    # Comment out if using external database
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - my-money-network
    healthcheck:
      # Enhanced health check using Node.js HTTP client with timeout
      # Checks health endpoint and validates JSON response
      # Accepts both 'ok' and 'degraded' status as healthy
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:4000/health', {timeout: 5000}, (r) => {let d='';r.on('data',c=>d+=c);r.on('end',()=>{try{const j=JSON.parse(d);const healthy=j.status==='ok'||j.status==='degraded';process.exit(healthy?0:1)}catch{process.exit(r.statusCode===200?0:1)}})}).on('error',()=>process.exit(1)).on('timeout',()=>process.exit(1))"]
      interval: 20s
      timeout: 8s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        compress: "true"
    restart: unless-stopped
    security_opt:
      - no-new-privileges:true
    # Read-only root filesystem for maximum security
    # Write access is provided via tmpfs mounts for required directories
    read_only: true
    tmpfs:
      - /tmp:noexec,nosuid,size=100m
      - /var/tmp:noexec,nosuid,size=50m
      # Prisma may need cache directory (optional, but safer to provide)
      - /app/backend/.prisma:noexec,nosuid,size=10m

  frontend:
    build:
      context: ..
      dockerfile: docker/Dockerfile.frontend
      args:
        BUILD_DATE: ${BUILD_DATE:-$(date -u +'%Y-%m-%dT%H:%M:%SZ')}
        VCS_REF: ${VCS_REF:-$(git rev-parse --short HEAD 2>/dev/null || echo 'unknown')}
        VERSION: ${VERSION:-1.0.0}
        NODE_VERSION: ${NODE_VERSION:-25.2.1}
        NGINX_VERSION: ${NGINX_VERSION:-alpine}
    container_name: my-money-frontend
    labels:
      - "com.docker.compose.project=my-money"
      - "com.docker.compose.service=frontend"
      - "security.scan=true"
      - "security.policy=restricted"
    ports:
      - "${FRONTEND_PORT:-3000}:80"
    depends_on:
      backend:
        condition: service_healthy
    networks:
      - my-money-network
    healthcheck:
      # Enhanced health check for frontend nginx
      # Tests both nginx configuration and HTTP endpoint availability
      # Uses curl for reliable HTTP check (matches Dockerfile HEALTHCHECK)
      test: ["CMD-SHELL", "nginx -t && curl -f http://127.0.0.1/health >/dev/null 2>&1"]
      interval: 20s
      timeout: 8s
      retries: 3
      start_period: 15s
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          cpus: '0.1'
          memory: 128M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        compress: "true"
    restart: unless-stopped
    security_opt:
      - no-new-privileges:true
    # Read-only root filesystem for maximum security
    # Nginx runtime files are provided via tmpfs mounts
    read_only: true
    tmpfs:
      - /var/cache/nginx:noexec,nosuid,size=50m
      - /var/log/nginx:noexec,nosuid,size=20m
      - /var/run:noexec,nosuid,size=10m
      - /tmp:noexec,nosuid,size=50m

volumes:
  postgres_data:
    name: mymoney_postgres_data
    driver: local

networks:
  my-money-network:
    driver: bridge
    labels:
      - "com.docker.compose.network=my-money-network"
      - "com.docker.compose.project=my-money"
    # Subnet is not specified - Docker will auto-assign a non-conflicting subnet
    # If you need a specific subnet, uncomment and set the subnet below:
    # ipam:
    #   config:
    #     - subnet: 172.20.0.0/16


